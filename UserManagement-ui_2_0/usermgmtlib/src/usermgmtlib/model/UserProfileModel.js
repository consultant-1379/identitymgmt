define([
    'identitymgmtlib/mvp/Model',
    'jscore/ext/net',
    'jscore/ext/utils/base/underscore',
    './RolePrivilegesCollection',
    './RolePrivilegesModel',
    '../validators/username.validator',
    '../validators/name.validator',
    '../validators/surname.validator',
    '../validators/password.validator',
    '../validators/email.validator',
    '../validators/passwordageing.validator',
    'usermgmtlib/services/UserManagementService',
    'identitymgmtlib/Utils'
], function(Model, net, _, RolePrivilegesCollection, RolePrivilegesModel, usernameValidator, nameValidator, surnameValidator, passwordValidator, emailValidator, passwordAgeingValidator, service, Utils) {

    var getRolePrivilegesCollection = function() {
        if (!this.privilegesCollection) {
            // create role privileges collection
            this.privilegesCollection = new RolePrivilegesCollection([]);

            // trigger extra event change when change:privileges occurs in assigned collection
            this.privilegesCollection.addEventHandler('change', function() {
                this.trigger('change:privileges', this, this.get('privileges'));
                this.trigger('change', this);
            }.bind(this));

            this.privilegesCollection.addEventHandler('fetch:privilegesCollection', function() {
                setServiceTargetGroups.call(this);
            }.bind(this));
        }
        return this.privilegesCollection;
    };

    var setPrivilegesFromRest = function(privileges, options) {

        // get privileges collection (or if not initialized then init it and return)
        var privilegesCollection = getRolePrivilegesCollection.call(this);

        // convert received privileges to suitable for RolePrivilegesModel
        var convertedPrivileges = convertUserPrivilegesToModelData.call(this, privileges || []);

        privilegesCollection.each(function(privilege) {
            privilege.reset();
        });

        privilegesCollection.setModels(
            convertedPrivileges, {
                /*add: false,*/
                remove: false
            }
        );
    };

    var setServiceTargetGroups = function() {
        var tgs = [];

        this.privilegesCollection.each(function(privilege) {
            var assigned = privilege.getAttribute('assigned');
            var type = privilege.getAttribute('type');

            if ( assigned === true && Utils.isServiceRole(privilege) ) {
                privilege.getAttribute('tgs').forEach( function(tg) {
                    if ( tgs.indexOf(tg) === -1 ) {
                        tgs.push(tg);
                    }
                }.bind(this));
            }
        }.bind(this));

        // I can have wrong configuration generated by REST.
        // In this case we fix incongruences
        if ( tgs.indexOf('ALL') > -1 ) {
            tgs = ['ALL'];
        } else if ( tgs.length > 1 ) {
            var index = tgs.indexOf('NONE');
            if ( index !== -1 ) {
                tgs.splice(index, 1);
            }
        }

        if ( tgs.length > 0 ) {
            this.setAttribute('tgs', tgs );
        } else {
            this.setAttribute('tgs', ['ALL'] ); // Default for Service TGs
        }
    };

    var convertUserPrivilegesToModelData = function(privileges) {

        // convert privileges to object to get unique role names
        var objPrivileges = {};
        privileges.forEach(function(privilege) {
            var roleName = privilege.role;
            objPrivileges[roleName] = objPrivileges[roleName] || [];
            objPrivileges[roleName].push(privilege.targetGroup);
        });

        // copy above privileges to array form object
        var privilegesArray = [];
        for (var privilege in objPrivileges) {
            privilegesArray.push({
                name: privilege,
                tgs: objPrivileges[privilege],
                assigned: true
            });
        }

        return privilegesArray;
    };


    var isPasswordsChanged = function() {
        return (this.lastPassword !== this.get('password') || this.lastConfirmPassword !== this.get('passwordConfirm'));
    };

    var isNameSurnameUsernameChanged = function() {
        return (this.lastUsername !== this.get('username') || this.lastName !== this.get('name') || this.lastSurname !== this.get('surname'));
    };

    var updateFormLastValues = function() {
        this.lastPassword = this.get('password');
        this.lastConfirmPassword = this.get('passwordConfirm');
        this.lastUsername = this.get('username');
        this.lastName = this.get('name');
        this.lastSurname = this.get('surname');
    };

    return Model.extend({

        // TODO: uncoment this when validation will be switched from username to uname
        idAttribute: 'username',

        url: "/oss/idm/usermanagement/users",

        notSync: ['passwordConfirm', 'lastLogin', 'previousLogin'],

        passwordPoliciesCollection: null,

        defaults: {
            status: 'disabled',
            passwordResetFlag: true
        },

        init: function() {
            Model.prototype.init.call(this);
            this.dump = this.toJSON();
        },

        parse: function(data) {
            setPrivilegesFromRest.call(this, data.privileges);
            data.privileges = getRolePrivilegesCollection.call(this);
            return data;
        },

        toJSON: function() {
            var data = Model.prototype.toJSON.call(this);

            // Need to be removed since poor backed cannot send GET method wihout password
            // that's way ****** are as value of password, and other not needed fields (sic!)
            if (this.getSaveMode() === "update") {
                // update
                delete data.password;
            }

            if (data.privileges) {
                var privileges = [];

                // get only assigned privileges from collection to save
                data.privileges.filter(function(role) {
                    return role.assigned;
                }).forEach(function( role ) {

                        role.tgs.forEach(function(tg) {
                            privileges.push({
                                role: role.name,
                                targetGroup: tg
                            });
                        });
                }.bind(this));

                data.privileges = privileges;
                delete data.tgs;
                delete data.serviceTgsChanged;
            }

            return data;
        },

        validate: function(strict, saveButton) {
            return new Promise(function(resolve, reject) {

                var result = {};

                // validate username
                if (this.shouldBeValidated('username')) {
                    result.username = usernameValidator.validate(this.get('username'), this.isStrictMode());
                }

                // validate name
                if (this.shouldBeValidated('name')) {
                    result.name = nameValidator.validate(this.get('name'), this.isStrictMode());
                }

                // validate surname
                if (this.shouldBeValidated('surname')) {
                    result.surname = surnameValidator.validate(this.get('surname'), this.isStrictMode());
                }

                // validate email
                if (this.shouldBeValidated('email')) {
                    result.email = emailValidator.validate(this.get('email'), this.isStrictMode());
                }
                // validate customized Password Ageing
                if(strict && this.get('passwordAgeing') && this.get('passwordAgeing').customizedPasswordAgeingEnable && this.get('passwordAgeing').passwordAgeingEnable) {
                    result.passwordAgeing = passwordAgeingValidator.validate(this.get('passwordAgeing'), this.isStrictMode());
                }

                // validate privileges
                result.privileges = this.get('privileges').validate(this.isStrictMode());

                // validate password and confirm password
                // TODO: should be performed only when password, passwordConfirm or username changed
                // but first result should be stored to not lost previous failed result
                if ( saveButton && this.mode !== 'edit') {
                        passwordValidator.validate({
                            policiesCollection: this.passwordPoliciesCollection,
                            password: this.get('password'),
                            passwordConfirm: this.get('passwordConfirm'),
                            strictMode: this.isStrictMode(),
                            saveButton: saveButton,
                            username: this.get('username'),
                            name: this.get('name'),
                            surname: this.get('surname'),
                            isPasswordsChanged: isPasswordsChanged.call(this),
                            isNameSurnameUsernameChanged: isNameSurnameUsernameChanged.call(this)
                        }).then(function(validationObject) {
                            updateFormLastValues.call(this);
                            result.password = validationObject;
                            result.passwordConfirm = result.password;
                            resolve(result);
                            this.validationObject = validationObject;
                        }.bind(this))
                        .catch(function(error) {
                             resolve(result);
                         });
                } else if (this.shouldBeValidated('password') || this.shouldBeValidated('passwordConfirm')) {
                    if ( isPasswordsChanged.call(this) || isNameSurnameUsernameChanged.call(this) ) {
                        passwordValidator.validate({
                            policiesCollection: this.passwordPoliciesCollection,
                            password: this.get('password'),
                            passwordConfirm: this.get('passwordConfirm'),
                            strictMode: this.isStrictMode(),
                            saveButton: saveButton,
                            username: this.get('username'),
                            name: this.get('name'),
                            surname: this.get('surname'),
                            isPasswordsChanged: isPasswordsChanged.call(this),
                            isNameSurnameUsernameChanged: isNameSurnameUsernameChanged.call(this)
                        }).then(function(validationObject) {
                            updateFormLastValues.call(this);
                            result.password = validationObject;
                            result.passwordConfirm = result.password;
                            resolve(result);
                            this.validationObject = validationObject;
                        }.bind(this))
                        .catch(function(error) {
                             resolve(result);
                         });
                     } else {
                        if ( this.validationObject ) {
                            result.password = this.validationObject;
                            result.passwordConfirm = result.password;
                            resolve(result);
                        }
                     }

                } else {
                    resolve(result);
                }

            }.bind(this));

        },

        // TODO: should be removed when poor backend 
        // starts to providing proper GET method with privileges
        fetch: function(options) {
            return Model.prototype.fetch.call(this, _.extend({}, options, {
                success: function() {
                    return this.getPrivileges(this.get('username'))
                        .then(function(privileges) {
                            setPrivilegesFromRest.call(this, privileges);
                            if (options && options.success) {
                                options.success.apply(arguments);
                            }
                        }.bind(this))
                        .catch(function() {
                            if (options && options.error) {
                                options.error.apply(arguments);
                            }
                        }.bind(this));
                }.bind(this),
                error: function() {
                    if (options && options.error) {
                        options.error.apply(arguments);
                    }
                }.bind(this)
            }));
            // TODO: end of removing part
        },

        getPrivileges: function(username) {
            return service.getUserPrivileges(username);
        },


        save: function(attr, options) {
            Model.prototype.save.call(this, attr, options);
            this.dump = this.toJSON();
        },


        hasChanged: function() {

            //remove attribute with value ""
            // for (var key in this.attributes) {
            //     if (this.getAttribute(key) === "") {
            //         this.removeAttribute(key);
            //     }
            // }

            var model = this.toJSON();
            var dump  = this.dump;

            dump.privileges  = _.sortBy(dump.privileges, 'role');
            model.privileges = _.sortBy(model.privileges, 'role');

            if ((JSON.stringify(dump) !== JSON.stringify(model))) {
                return true;
            } else {
                return false;
            }

        }


    });

});
